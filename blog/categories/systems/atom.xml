<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Systems | Jay McCarthy]]></title>
  <link href="http://jeapostrophe.github.com/blog/categories/systems/atom.xml" rel="self"/>
  <link href="http://jeapostrophe.github.com/"/>
  <updated>2012-06-19T12:29:22-06:00</updated>
  <id>http://jeapostrophe.github.com/</id>
  <author>
    <name><![CDATA[Jay McCarthy]]></name>
    <email><![CDATA[jay.mccarthy@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[exec and Tail-call Optimization]]></title>
    <link href="http://jeapostrophe.github.com/blog/2012/05/28/exec-vs-system/"/>
    <updated>2012-05-28T00:00:00-06:00</updated>
    <id>http://jeapostrophe.github.com/blog/2012/05/28/exec-vs-system</id>
    <content type="html"><![CDATA[<p>I’m often bothered by programs that fail to use exec properly and
instead use system. In this article, we’ll review the difference and
relate it to tail-call optimization.</p>

<!-- more -->


<p>In Unix, there’s not really a way to start a totally new process.
Instead, every process comes into being by another process duplicating
itself with fork(). The two processes are identical at that point,
except that the fork() call returns 0 to the child and the child’s PID
to the parent. Using this information, the two can behave differently.</p>

<p>Often, what the child will do is change the program entirely by loading
a system binary and executing its main function. That task is taken care
of by the exec function, which receives the path to the binary, plus the
arguments, and, optionally, the environment.</p>

<p>Most programming languages give you access to a function named exec
which is a wrapper for this functionality. Its also likely that they
will also give a function named system that behaves almost the same.
It’s main difference is that it returns the exit code of the program
when it exits and it invokes the shell to parse the command-line
arguments and look up the binary’s full path.</p>

<p>If your program calls system in tail-position, meaning that the program
does nothing with the exit code nor does anything else after ward, then
you are wasting memory. In particular, the memory of the parent process
which has nothing to do. You should have just exec’d, not forked and
then exec’d.</p>

<p>Here’s an example:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>bad.sh </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="c">#!/bin/bash</span>
</span><span class='line'>                               &lt;br/&gt;
</span><span class='line'><span class="nv">x</span><span class="o">=</span><span class="k">${</span><span class="nv">1</span><span class="k">:-</span><span class="nv">10</span><span class="k">}</span>                     &lt;br/&gt;
</span><span class='line'>                               &lt;br/&gt;
</span><span class='line'><span class="k">if</span> <span class="o">[</span> <span class="nv">$x</span> -eq 0 <span class="o">]</span> ; <span class="k">then</span>         &lt;br/&gt;
</span><span class='line'>    read                       &lt;br/&gt;
</span><span class='line'>    echo <span class="k">done</span>                  &lt;br/&gt;
</span><span class='line'><span class="k">else</span>                           &lt;br/&gt;
</span><span class='line'>    ./bad.sh <span class="k">$(</span>expr <span class="nv">$x</span> - 1<span class="k">)</span>    &lt;br/&gt;
</span><span class='line'><span class="k">fi</span>                             &lt;br/&gt;
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>The process tree for this bad code looks like this:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;br/>
</span><span class='line'>/bin/zsh                                              &lt;br/>
</span><span class='line'> _ bash bad.sh                                       &lt;br/>
</span><span class='line'>|   _ bash bad.sh 9                                  &lt;br/>
</span><span class='line'>|       _ bash bad.sh 8                              &lt;br/>
</span><span class='line'>|           _ bash bad.sh 7                          &lt;br/>
</span><span class='line'>|               _ bash bad.sh 6                      &lt;br/>
</span><span class='line'>|                   _ bash bad.sh 5                  &lt;br/>
</span><span class='line'>|                       _ bash bad.sh 4              &lt;br/>
</span><span class='line'>|                           _ bash bad.sh 3          &lt;br/>
</span><span class='line'>|                               _ bash bad.sh 2      &lt;br/>
</span><span class='line'>|                                   _ bash bad.sh 1  &lt;br/>
</span><span class='line'>|                                       _ bash bad.sh 0
</span><span class='line'> _ ps f                                              &lt;br/></span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Compared to:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>good.sh </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="c">#!/bin/bash</span>
</span><span class='line'>                                &lt;br/&gt;
</span><span class='line'><span class="nv">x</span><span class="o">=</span><span class="k">${</span><span class="nv">1</span><span class="k">:-</span><span class="nv">10</span><span class="k">}</span>                      &lt;br/&gt;
</span><span class='line'>                                &lt;br/&gt;
</span><span class='line'><span class="k">if</span> <span class="o">[</span> <span class="nv">$x</span> -eq 0 <span class="o">]</span> ; <span class="k">then</span>          &lt;br/&gt;
</span><span class='line'>    read                        &lt;br/&gt;
</span><span class='line'>    echo <span class="k">done</span>                   &lt;br/&gt;
</span><span class='line'><span class="k">else</span>                            &lt;br/&gt;
</span><span class='line'>    exec ./good.sh <span class="k">$(</span>expr <span class="nv">$x</span> - 1<span class="k">)</span>
</span><span class='line'><span class="k">fi</span>                              &lt;br/&gt;
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>(Notice that line 9 is different—we’ve explicitly used exec.)</p>

<p>This good code has a process tree like:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;br/>
</span><span class='line'>/bin/zsh        &lt;br/>
</span><span class='line'> _ bash good.sh 0
</span><span class='line'> _ ps f        &lt;br/></span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>This is very similar to the concept of safe-for-space, or tail-call
optimization, in programming languages. As you can see, unfortunately
bash is not safe-for-space by default. That is, it doesn’t keep track of
when a call is in tail-position and automatically use exec rather than
system.</p>

<p>It’s not just a problem with bash either, I’ve never known any shell
that can run this program correctly.</p>

<p>In most cases, this is not problematic because the stack is unlikely to
grow very large and the executed program is unlikely to run for a long
time. However, it most often shows up as a problem with X11 window
managers and menu programs.</p>

<p>Your Xsession initialization should always exec your window manager,
because there’s nothing else it needs to do afterward.</p>

<p>An X11 menu program should also use exec to run the program, otherwise
whenever you start, for example Emacs, the shell that started it will
persist for the entire time you are running Emacs (presumably the entire
time you are at the computer.) In addition, you should exec your menu
program so that the shell that starts it is replaced as well.</p>

<p>For example, the default Xmonad configuration does not do this correctly
and will invoke dmenu without an exec, leaving around the shell forever.
(dmenu is programmed correctly, though.)</p>

<p>So, raise your right arm and say with me: "I will always exec in
tail-position!"</p>
]]></content>
  </entry>
  
</feed>
